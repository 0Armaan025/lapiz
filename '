import html2canvas from 'html2canvas';
import { CardElement, CardSettings } from '../create/page';

export interface ExportOptions {
  format: 'png' | 'svg' | 'jpeg';
  quality?: number;
  transparentBackground?: boolean;
  scale?: number;
}

export class CardExporter {
  /**
   * Export card as PNG with enhanced options
   */
  async exportAsPNG(
    cardElement: HTMLElement,
    settings: CardSettings,
    options: ExportOptions = { format: 'png', scale: 2, transparentBackground: false }
  ): Promise<Blob> {
    try {
      // Clone the element to modify it without affecting the original
      const clone = cardElement.cloneNode(true) as HTMLElement;

      // Handle transparent background
      if (options.transparentBackground) {
        const cardDiv = clone.querySelector('.card') as HTMLElement;
        if (cardDiv) {
          cardDiv.style.backgroundColor = 'transparent';
          cardDiv.style.backgroundImage = 'none';
        }
      }

      const canvas = await html2canvas(clone, {
        backgroundColor: options.transparentBackground ? null : settings.backgroundColor,
        scale: options.scale || 2,
        width: settings.width,
        height: settings.height,
        logging: false,
        useCORS: true,
        allowTaint: true,
        removeContainer: true,
      });

      return new Promise((resolve, reject) => {
        canvas.toBlob(
          (blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error('Failed to create blob'));
            }
          },
          options.format === 'jpeg' ? 'image/jpeg' : 'image/png',
          options.quality || 1.0
        );
      });
    } catch (error) {
      console.error('Error exporting as PNG:', error);
      throw error;
    }
  }

  /**
   * Export card as SVG (for vector graphics)
   */
  async exportAsSVG(
    cardElement: HTMLElement,
    settings: CardSettings,
    transparentBackground: boolean = false
  ): Promise<Blob> {
    try {
      const svgContent = this.generateSVGFromElement(cardElement, settings, transparentBackground);
      return new Blob([svgContent], { type: 'image/svg+xml' });
    } catch (error) {
      console.error('Error exporting as SVG:', error);
      throw error;
    }
  }

  /**
   * Generate SVG string from card element
   */
  private generateSVGFromElement(
    cardElement: HTMLElement,
    settings: CardSettings,
    transparentBackground: boolean
  ): string {
    // Basic SVG wrapper
    const bgColor = transparentBackground ? 'none' : settings.backgroundColor;

    return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${settings.width}" height="${settings.height}" 
     xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <rect width="100%" height="100%" fill="${bgColor}" 
        rx="${settings.borderRadius}" 
        stroke="${settings.borderColor}" 
        stroke-width="${settings.borderWidth}"/>
  <!-- Card content would be rendered here as SVG elements -->
</svg>`;
  }

  /**
   * Download blob as file
   */
  downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Copy image to clipboard
   */
  async copyImageToClipboard(blob: Blob): Promise<boolean> {
    try {
      if (!navigator.clipboard || !navigator.clipboard.write) {
        console.warn('Clipboard API not supported');
        return false;
      }

      const item = new ClipboardItem({ [blob.type]: blob });
      await navigator.clipboard.write([item]);
      return true;
    } catch (error) {
      console.error('Error copying to clipboard:', error);
      return false;
    }
  }

  /**
   * Generate data URL for preview
   */
  async generateDataURL(
    cardElement: HTMLElement,
    settings: CardSettings,
    options: ExportOptions = { format: 'png', scale: 2 }
  ): Promise<string> {
    const blob = await this.exportAsPNG(cardElement, settings, options);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  /**
   * Generate API endpoint code for dynamic README
   */
  generateAPIEndpointCode(username: string, cardId?: string): string {
    // This would be your actual API endpoint
    const apiUrl = `https://your-api.vercel.app/api/card/${username}${cardId ? `?id=${cardId}` : ''}`;
    return apiUrl;
  }

  /**
   * Generate README markdown with dynamic image
   */
  generateReadmeMarkdown(username: string, cardId?: string): string {
    const apiUrl = this.generateAPIEndpointCode(username, cardId);
    return `![GitHub Stats](${apiUrl})`;
  }

  /**
   * Generate README HTML with dynamic image
   */
  generateReadmeHTML(username: string, profileUrl: string, cardId?: string): string {
    const apiUrl = this.generateAPIEndpointCode(username, cardId);
    return `<a href="${profileUrl}">
  <img src="${apiUrl}" alt="${username}'s GitHub Stats" />
</a>`;
  }

  /**
   * Generate shareable JSON config for card
   */
  generateCardConfig(elements: CardElement[], settings: CardSettings, username: string): string {
    const config = {
      version: '1.0',
      username,
      settings,
      elements,
      timestamp: new Date().toISOString(),
    };
    return JSON.stringify(config, null, 2);
  }

  /**
   * Export card configuration
   */
  exportConfig(elements: CardElement[], settings: CardSettings, username: string) {
    const config = this.generateCardConfig(elements, settings, username);
    const blob = new Blob([config], { type: 'application/json' });
    this.downloadBlob(blob, `github-card-${username}-config.json`);
  }

  /**
   * Import card configuration
   */
  async importConfig(file: File): Promise<{ elements: CardElement[]; settings: CardSettings; username: string } | null> {
    try {
      const text = await file.text();
      const config = JSON.parse(text);
      return {
        elements: config.elements,
        settings: config.settings,
        username: config.username,
      };
    } catch (error) {
      console.error('Error importing config:', error);
      return null;
    }
  }
}

export const cardExporter = new CardExporter();
